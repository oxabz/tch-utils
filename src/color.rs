use tch::Tensor;

const RGB_FROM_HED : &[f32; 9] = &[
    0.65, 0.70, 0.29,
    0.07, 0.99, 0.11,
    0.27, 0.57, 0.78
];

const HED_FROM_RGB: &[f32; 9] = &[
    1.8779827368521356592,    -1.007678686285564546,  -0.5561158181996246681,
    -0.065908062223563323342, 1.1347303724996625189,  -0.1355217986283711709,
    -0.60190736343928914578,  -0.4804141884970579594, 1.5735880719641925997
];

/**
Convert a tensor of HED values to RGB values.

# Arguments
- hed: Tensor - The tensor of HED values [N, 3, H, W] with float values in the range [0, 1]

# Returns
Tensor - The tensor of RGB values [N, 3, H, W] with float values in the range [0, 1]
 */
pub fn rgb_from_hed(hed: &Tensor) -> Tensor {
    let rgb_from_hed = Tensor::of_slice(RGB_FROM_HED).view([3, 3]).to_device(hed.device());
    hed.transpose(1, 3).matmul(&rgb_from_hed).transpose(1, 3)
}

/**
Convert a tensor of RGB values to HED values.

# Arguments
- rgb: Tensor - The tensor of RGB values [N, 3, H, W] with float values in the range [0, 1]

# Returns
Tensor - The tensor of HED values [N, 3, H, W] with float values in the range [0, 1]
 */
pub fn hed_from_rgb(rgb: &Tensor) -> Tensor {
    let hed_from_rgb = Tensor::of_slice(HED_FROM_RGB).view([3, 3]).to_device(rgb.device());
    rgb.transpose(1, 3).matmul(&hed_from_rgb).transpose(1, 3)
}

/**
Convert a tensor of RGB values to HSV values.

# Arguments
- rgb: Tensor - The tensor of RGB values [N, 3, H, W] with float values in the range [0, 1]

# Returns
Tensor - The tensor of HSV values [N, 3, H, W] with float values in the range [0, 1]
 */
pub fn hsv_from_rgb(rgb: &Tensor) -> Tensor {
    let (max /* [N, H, W] */, _) = rgb.max_dim(1, false);
    let (min /* [N, H, W] */, _) = rgb.min_dim(1, false); 
    let delta /* [N, H, W] */ = &max - min; 
    let mut h  /* [N, H, W] */ = Tensor::zeros_like(&delta); 
    h += rgb.select(1, 0).eq_tensor(&delta) 
        * ((rgb.select(1, 1) - rgb.select(1, 2)) / &delta).fmod(6.0) * 60.0;
    h += rgb.select(1, 1).eq_tensor(&delta) 
        * ((rgb.select(1, 2) - rgb.select(1, 0)) / &delta + 2.0) * 60.0;
    h += rgb.select(1, 2).eq_tensor(&delta) 
        * ((rgb.select(1, 0) - rgb.select(1, 1)) / &delta + 4.0) * 60.0;
    h = h.fmod(360.0);
    let s  /* [N, H, W] */ = &delta / &max; 
    let s = s.where_scalarother(&max.eq_tensor(&Tensor::zeros_like(&max)), 0);
    let v  /* [N, H, W] */ = max; 

    Tensor::stack(&[h, s, v], 1)
}

#[cfg(test)]
mod test{
    /*!
     * Tests for the color module
     * To test the color we use tensors generated by the skimage library in python.
     * The tensor are saved in the `test-assets/colors` folder and loaded in the tests.
     */

    use super::*;
    use crate::utils::{assert_tensor_asset, assert_eq_tensor, self};
    
    #[test]
    fn test_rgb_from_hed() {
        let hed = utils::dirty_load("test-assets/colors/hed.npy");
        let rgb = rgb_from_hed(&hed);
        
        assert_tensor_asset(&rgb, "test-assets/colors/original.npy");
    }

    #[test]
    fn test_hed_hsv_back_and_forth() {
        let original = utils::dirty_load("test-assets/colors/original.npy");
        let hed = hed_from_rgb(&original);
        let rgb = rgb_from_hed(&hed);

        assert_eq_tensor(&original, &rgb);
    }

    #[test]
    fn test_hsv_from_rgb() {
        let rgb = utils::dirty_load("test-assets/colors/original.npy");
        let hsv = hsv_from_rgb(&rgb);
        
        assert_tensor_asset(&hsv, "test-assets/colors/hsv.npy");
    }
}